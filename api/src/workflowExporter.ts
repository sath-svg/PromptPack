// Workflow exporter for MCP server
// Ported from app/src/lib/workflowExporter.ts
// Generates Claude Skill markdown and structured JSON workflows

import { parseTemplateVariables, replaceTemplateVariables } from './templateParser';

export interface WorkflowPrompt {
  text: string;
  header?: string;
}

export interface WorkflowStep {
  step: number;
  title: string;
  prompt: string;
  depends_on_previous: boolean;
}

export interface StructuredWorkflow {
  title: string;
  description: string;
  steps: WorkflowStep[];
  variables: string[];
}

/** Get slug for a pack title (lowercase, hyphens, max 64 chars) */
export function getSkillDirName(packTitle: string): string {
  return packTitle
    .replace(/[^a-zA-Z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .toLowerCase()
    .slice(0, 64) || 'workflow';
}

/** Generate Claude Skill markdown format */
export function generateMarkdownWorkflow(packTitle: string, prompts: WorkflowPrompt[], variables?: Record<string, string>): string {
  const lines: string[] = [];
  const slug = getSkillDirName(packTitle);

  const stepNames = prompts.map((p, i) => p.header || `Step ${i + 1}`);
  const stepSummary = stepNames.join(' → ');

  // YAML frontmatter
  lines.push('---');
  lines.push(`name: ${slug}`);
  lines.push(`description: "Multi-step prompt workflow: ${stepSummary}. Exported from PromptPack."`);
  lines.push('disable-model-invocation: true');
  lines.push('---');
  lines.push('');

  lines.push(`# ${packTitle}`);
  lines.push('');
  lines.push('A multi-step prompt workflow where each step builds on the previous output.');
  lines.push('');

  // Collect all unique template variables
  const allVars = new Set<string>();
  for (const prompt of prompts) {
    for (const v of parseTemplateVariables(prompt.text)) {
      allVars.add(v);
    }
  }

  if (allVars.size > 0) {
    lines.push('## Variables');
    lines.push('');
    lines.push('This workflow uses template variables. Before executing any step, ask the user to provide a value for each variable listed below. The variable name describes what value is needed.');
    lines.push('');
    lines.push('| Variable | Value |');
    lines.push('|----------|-------|');
    for (const v of allVars) {
      lines.push(`| ${v} | _____ |`);
    }
    lines.push('');
    lines.push('Replace every `{VariableName}` placeholder in the prompts below with the value the user provides.');
    lines.push('');
  }

  lines.push('## Workflow Steps');
  lines.push('');

  for (let i = 0; i < prompts.length; i++) {
    const prompt = prompts[i];
    const stepNum = i + 1;
    const title = prompt.header || `Step ${stepNum}`;

    lines.push(`### Step ${stepNum}: ${title}`);
    lines.push('');

    if (i === 0) {
      lines.push('Execute the following prompt:');
    } else {
      lines.push('Using the output from the previous step as context, execute the following prompt:');
    }

    let promptText = prompt.text;
    if (variables) {
      promptText = replaceTemplateVariables(promptText, variables);
    }

    lines.push('');
    lines.push('```');
    lines.push(promptText);
    lines.push('```');
    lines.push('');
  }

  lines.push('## Notes');
  lines.push('');
  lines.push("- Each step's output should be provided as context when executing the next step.");
  lines.push('- Generated by PromptPack.');
  lines.push('');

  return lines.join('\n');
}

/** Generate structured JSON workflow */
export function generateStructuredWorkflow(packTitle: string, prompts: WorkflowPrompt[], variables?: Record<string, string>): StructuredWorkflow {
  const allVars = new Set<string>();
  for (const prompt of prompts) {
    for (const v of parseTemplateVariables(prompt.text)) {
      allVars.add(v);
    }
  }

  const stepNames = prompts.map((p, i) => p.header || `Step ${i + 1}`);

  const steps: WorkflowStep[] = prompts.map((prompt, i) => {
    let promptText = prompt.text;
    if (variables) {
      promptText = replaceTemplateVariables(promptText, variables);
    }
    return {
      step: i + 1,
      title: prompt.header || `Step ${i + 1}`,
      prompt: promptText,
      depends_on_previous: i > 0,
    };
  });

  return {
    title: packTitle,
    description: `Multi-step prompt workflow: ${stepNames.join(' → ')}`,
    steps,
    variables: Array.from(allVars),
  };
}
