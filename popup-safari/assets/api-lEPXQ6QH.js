const u="https://pmtpk.com",i="https://api.pmtpk.com",l="https://determined-lark-313.convex.site",g="https://grok.pmtpk.com";const R=`${u}/extension-auth`,L=`${u}/dashboard`,S=`${u}/pricing`,x=`${u}/sign-out`,D=`${u}/api/packs/create`,b=`${g}/api/enhance`,k=10,m=40,$=2,w=4320*60*1e3,j=3,C=100,U="_backup_",q=5*1024*1024,E="promptpack",A=1,B="promptpack_prompts",I=1,O=14,_=/^[a-zA-Z0-9]+$/;function M(a){return a.length>=I&&a.length<=O&&_.test(a)}const F=900,y=2,T=40;let p=null;function f(){return p?Promise.resolve(p):new Promise((a,e)=>{const t=indexedDB.open(E,A);t.onerror=()=>e(t.error),t.onsuccess=()=>{p=t.result,a(p)},t.onupgradeneeded=r=>{const s=r.target.result;if(!s.objectStoreNames.contains("prompts")){const o=s.createObjectStore("prompts",{keyPath:"id"});o.createIndex("source","source",{unique:!1}),o.createIndex("syncStatus","syncStatus",{unique:!1}),o.createIndex("createdAt","createdAt",{unique:!1})}if(!s.objectStoreNames.contains("packs")){const o=s.createObjectStore("packs",{keyPath:"id"});o.createIndex("isLoaded","isLoaded",{unique:!1}),o.createIndex("isPurchased","isPurchased",{unique:!1})}s.objectStoreNames.contains("session")||s.createObjectStore("session",{keyPath:"id"})}})}async function d(){const a=await f();return new Promise((e,t)=>{const o=a.transaction("session","readonly").objectStore("session").get("current");o.onsuccess=()=>e(o.result),o.onerror=()=>t(o.error)})}async function P(a){const e=await f(),t={...a,id:"current"};return new Promise((r,s)=>{const c=e.transaction("session","readwrite").objectStore("session").put(t);c.onsuccess=()=>r(t),c.onerror=()=>s(c.error)})}async function h(){const a=await f();return new Promise((e,t)=>{const o=a.transaction("session","readwrite").objectStore("session").delete("current");o.onsuccess=()=>e(),o.onerror=()=>t(o.error)})}class N{async classifyViaBackground(e,t){return chrome?.runtime?.sendMessage?new Promise(r=>{chrome.runtime.sendMessage({type:"PP_CLASSIFY",promptText:e,maxWords:t},s=>{if(chrome.runtime.lastError){r(null);return}r(s)})}):null}async verifyViaBackground(e){return chrome?.runtime?.sendMessage?new Promise(t=>{chrome.runtime.sendMessage({type:"PP_VERIFY_AUTH",token:e},r=>{if(chrome.runtime.lastError){t(null);return}const s=r?.ok;t(typeof s=="boolean"?s:null)})}):null}async getAuthHeaders(){const e=await d();if(!e||e.expiresAt<Date.now())throw{code:"UNAUTHORIZED",message:"Not authenticated",status:401};return{"Content-Type":"application/json",Authorization:`Bearer ${e.accessToken}`}}async request(e,t,r,s=!0){const o=s?await this.getAuthHeaders():{"Content-Type":"application/json"},n=await fetch(`${i}${t}`,{method:e,headers:o,body:r?JSON.stringify(r):void 0});if(!n.ok){const c=await n.json().catch(()=>({code:"UNKNOWN",message:n.statusText}));throw{code:c.code||"UNKNOWN",message:c.message||n.statusText,status:n.status}}return n.json()}async exchangeCodeForToken(e){const t=await fetch(`${l}/api/extension/exchange-code`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({code:e})});if(!t.ok)throw{code:"TOKEN_EXCHANGE_FAILED",message:(await t.json().catch(()=>({error:t.statusText}))).error||"Failed to exchange code for token",status:t.status};const r=await t.json();if(!r.success)throw{code:"TOKEN_EXCHANGE_FAILED",message:"Failed to exchange code",status:400};await P({userId:r.user.clerkId,email:r.user.email,tier:r.user.plan==="pro"?"paid":"free",accessToken:r.token,refreshToken:r.refreshToken||r.token,expiresAt:Date.now()+w,entitlements:{promptLimit:r.user.plan==="pro"?m:k,loadedPackLimit:r.user.plan==="pro"?y:0}})}async refreshToken(){const e=await d();if(!e?.refreshToken||e.refreshToken.includes(".")||e.refreshToken.length>100)return!1;try{const r=await fetch(`${i}/auth/refresh`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refreshToken:e.refreshToken})});if(!r.ok){const o=await r.json().catch(()=>({}));if(console.error("[PromptPack] Refresh failed:",r.status,o),o.error==="TOKEN_REUSE"||o.error==="TOKEN_REVOKED"||o.error==="INVALID_TOKEN"||o.error==="TOKEN_EXPIRED")return console.warn("[PromptPack] Refresh token invalid, clearing session"),await h(),!1;if(r.status===404)return console.warn("[PromptPack] Refresh endpoint not found - backend may need deployment"),!1;throw new Error(o.error||o.message||"Refresh failed")}const s=await r.json();return s.success?(await P({...e,...s.user&&{userId:s.user.clerkId,email:s.user.email,tier:s.user.plan==="pro"?"paid":"free",entitlements:{promptLimit:s.user.plan==="pro"?m:k,loadedPackLimit:s.user.plan==="pro"?y:0}},refreshToken:s.refreshToken||e.refreshToken,expiresAt:s.refreshTokenExpiresAt||(s.expiresIn?Date.now()+s.expiresIn*1e3:e.expiresAt)}),!0):(console.error("[PromptPack] Refresh response not successful:",s),await h(),!1)}catch(r){return console.error("[PromptPack] Token refresh failed:",r),r instanceof TypeError&&r.message.includes("fetch")?(console.warn("[PromptPack] Network error during refresh, keeping session"),!1):(await h(),!1)}}async logout(){const e=await d();try{await fetch(`${i}/auth/logout`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refreshToken:e?.refreshToken})})}catch{}await h()}async getEntitlements(){return this.request("GET","/entitlements")}async verifyAuthToken(e){const t=await this.verifyViaBackground(e);if(t!==null)return t;if(typeof location<"u"&&location.protocol!=="chrome-extension:")return!1;try{return(await fetch(`${i}/auth/status`,{method:"GET",headers:{Authorization:`Bearer ${e}`}})).ok}catch{return!1}}async verifyAuthSession(){const e=await this.verifyViaBackground();if(e!==null)return e;const t=await d();if(!t?.accessToken)return!1;try{return(await fetch(`${i}/auth/status`,{method:"GET",headers:{Authorization:`Bearer ${t.accessToken}`}})).ok}catch{return!1}}async syncPrompts(e){return this.request("POST","/prompts/sync",{prompts:e.map(t=>({localId:t.id,text:t.text,source:t.source,url:t.url,createdAt:new Date(t.createdAt).toISOString()}))})}async getPrompts(){return(await this.request("GET","/prompts")).prompts}async createPrompt(e){return this.request("POST","/prompts",e)}async deletePrompt(e){await this.request("DELETE",`/prompts/${e}`)}async deletePromptsBySource(e){return this.request("DELETE",`/prompts/source/${e}`)}async savePromptsToDashboard(e){if(!e.clerkId)return{success:!1,error:"Not authenticated"};const t=await this.checkDashboardPromptLimit(e.clerkId,e.source,e.promptCount);if(!t.allowed)return{success:!1,error:`Would exceed ${t.limit} prompt limit (current: ${t.currentTotal}, adding: ${e.promptCount})`};const r=btoa(JSON.stringify({userId:e.clerkId}));try{const s=await fetch(`${i}/storage/upload`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${r}`},body:JSON.stringify({source:e.source,fileData:e.fileData,promptCount:e.promptCount})});if(!s.ok)return{success:!1,error:(await s.json().catch(()=>({error:"Upload failed"}))).error||"Failed to upload to storage"};const o=await s.json();if(!o.success)return{success:!1,error:"Failed to upload to storage"};const n=await fetch(`${l}/api/extension/save-prompts`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({clerkId:e.clerkId,source:e.source,r2Key:o.r2Key,promptCount:e.promptCount,fileSize:o.size,headers:e.headers})});return n.ok?{success:!0,r2Key:o.r2Key}:{success:!1,error:(await n.json().catch(()=>({error:"Unknown error"}))).error||"Failed to save metadata"}}catch(s){return{success:!1,error:s instanceof Error?s.message:"Failed to save to dashboard"}}}async checkDashboardPromptLimit(e,t,r){try{const s=await fetch(`${l}/api/extension/check-prompt-limit`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({clerkId:e,source:t,addingCount:r})});return s.ok?await s.json():{allowed:!0,limit:T,currentTotal:0}}catch{return{allowed:!0,limit:T,currentTotal:0}}}async getMarketplacePacks(e){const t=new URLSearchParams;e?.category&&t.set("category",e.category),e?.search&&t.set("search",e.search),e?.page&&t.set("page",e.page.toString());const r=t.toString();return this.request("GET",`/marketplace/packs${r?`?${r}`:""}`)}async getPurchasedPacks(){return(await this.request("GET","/packs/purchased")).packs}async getLoadedPacks(){return(await this.request("GET","/packs/loaded")).packs}async purchasePack(e){return this.request("POST",`/packs/${e}/purchase`)}async loadPack(e){return this.request("POST",`/packs/${e}/load`)}async unloadPack(e){return this.request("POST",`/packs/${e}/unload`)}async downloadPack(e){const t=await this.getAuthHeaders(),r=await fetch(`${i}/packs/${e}/download`,{method:"GET",headers:t});if(!r.ok)throw{code:"DOWNLOAD_FAILED",message:"Failed to download pack",status:r.status};return r.arrayBuffer()}async getUpgradeUrl(){return{url:S}}async checkWebAuthStatus(){try{return null}catch{return null}}async getBillingStatus(e){const t=await fetch(`${l}/api/extension/billing-status`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({clerkId:e})});if(!t.ok)throw{code:"BILLING_STATUS_FAILED",message:(await t.json().catch(()=>({error:t.statusText}))).error||"Failed to get billing status",status:t.status};return t.json()}async classifyPrompt(e){try{const r=await this.classifyViaBackground(e,2);if(r)return r.ok&&r.header?{success:!0,header:r.header}:{success:!1,error:r.error||"Classification failed"};const s=await d();if(!s?.userId)return{success:!1,error:"Sign in required for AI-generated headers"};const o=await fetch(`${i}/classify`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({promptText:e.slice(0,500),maxWords:2,userId:s.userId})});return o.ok?{success:!0,header:(await o.json()).header}:{success:!1,error:(await o.json().catch(()=>({error:"Classification failed"}))).error||"Failed to classify"}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Network error"}}}}const G=new N;export{i as A,U as B,L as D,b as E,k as F,$ as M,B as P,C as R,x as S,F as T,O as a,G as b,D as c,m as d,j as e,q as f,d as g,h,M as i,R as j};
